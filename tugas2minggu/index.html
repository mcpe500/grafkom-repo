<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <style>
        #myCanvas {
            border: 1px solid black;
            float: left;
            margin: 10px;
        }
    </style>
</head>

<body>
    <div class="main">
        <canvas id="myCanvas" width="1000" height="720"></canvas>
        <div id="camera-position">
            <h3>Camera Position</h3>
            <label for="x">X: </label>
            <input type="number" id="camera-x" value="1.0" />
            <label for="y">Y: </label>
            <input type="number" id="camera-y" value="1.0" />
            <label for="z">Z: </label>
            <input type="number" id="camera-z" value="1.0" />
        </div>
        <div id="lookat-position">
            <h3>Look At Position</h3>
            <label for="x">X: </label>
            <input type="number" id="lookat-x" value="100.0" />
            <label for="y">Y: </label>
            <input type="number" id="lookat-y" value="0.0" />
            <label for="z">Z: </label>
            <input type="number" id="lookat-z" value="0.0" />
        </div>
        <div id="up-vector">
            <h3>Up Vector</h3>
            <input type="number" id="up-x" value="0.0" />
            <input type="number" id="up-y" value="1.0" />
            <input type="number" id="up-z" value="0.0" />
        </div>
        <div id="bukaan">
            <h3>Bukaan</h3>
            <p>Bukaan W :</p>
            <input type="number" name="bukaan-w" id="bukaan-w" value="60.0" />
            derajat
            <p>Bukaan H :</p>
            <input type="number" name="bukaan-h" id="bukaan-h" value="60.0" />
            derajat
        </div>
        <div id="clip">
            <h3>Clip</h3>
            <p>Clip Near :</p>
            <input type="number" name="clip-near" id="clip-near" value="1.0" />
            <p>Clip Far :</p>
            <input type="number" name="clip-far" id="clip-far" value="1000.0" />
        </div>
        <button onclick="drawCanvas(ctx)">Gambar</button>
    </div>
    <script src="./obj_files/LEGO_Man.js"></script>
    <script src="./utils.js"></script>
    <script>
        const canvas = document.getElementById("myCanvas");
        const ctx = canvas.getContext("2d");
        const size = 1;
        const positionX = 0;
        const positionY = 0;
        const positionZ = 0;

        function lookAt(
            eyeX,
            eyeY,
            eyeZ,
            lookAtX,
            lookAtY,
            lookAtZ,
            upX,
            upY,
            upZ
        ) {
            const eye = [eyeX, eyeY, eyeZ];
            const lookAt = [lookAtX, lookAtY, lookAtZ];
            const up = [upX, upY, upZ];

            const zAxis = normalize(subtract(eye, lookAt));
            const xAxis = normalize(cross(up, zAxis));
            const yAxis = cross(zAxis, xAxis);

            const viewMatrix = [
                [xAxis[0], xAxis[1], xAxis[2], -dot(xAxis, eye)],
                [yAxis[0], yAxis[1], yAxis[2], -dot(yAxis, eye)],
                [zAxis[0], zAxis[1], zAxis[2], -dot(zAxis, eye)],
                [0, 0, 0, 1],
            ];

            return viewMatrix;
        }
        function generateBukaanMatrix(bukaanW, bukaanH) {
            const radBukaanW = (bukaanW * Math.PI) / 180;
            const radBukaanH = (bukaanH * Math.PI) / 180;
            const scaleX = 1.0 / Math.tan(radBukaanW / 2);
            const scaleY = 1.0 / Math.tan(radBukaanH / 2);

            const matrix = [
                [scaleX, 0, 0, 0],
                [0, scaleY, 0, 0],
                [0, 0, 1, 0],
                [0, 0, 0, 1]
            ];

            return matrix;
        }
        function generatePerspectiveMatrix(clipNear, clipFar) {
            const k = clipNear / clipFar;

            const matrix = [
                [1, 0, 0, 0],
                [0, 1, 0, 0],
                [0, 0, (k - 1) / (1 - k), (2 * k) / (1 - k)],
                [0, 0, -1, 0]
            ];

            return matrix;
        }

        function generateFarScalingMatrix(clipFar) {
            const matrix = [
                [1 / clipFar, 0, 0, 0],
                [0, 1 / clipFar, 0, 0],
                [0, 0, 1 / clipFar, 0],
                [0, 0, 0, 1]
            ];

            return matrix;
        }


        function drawCanvas() {
            const cameraX = parseFloat(document.getElementById("camera-x").value);
            const cameraY = parseFloat(document.getElementById("camera-y").value);
            const cameraZ = parseFloat(document.getElementById("camera-z").value);
            const lookAtX = parseFloat(document.getElementById("lookat-x").value);
            const lookAtY = parseFloat(document.getElementById("lookat-y").value);
            const lookAtZ = parseFloat(document.getElementById("lookat-z").value);
            const upX = parseFloat(document.getElementById("up-x").value);
            const upY = parseFloat(document.getElementById("up-y").value);
            const upZ = parseFloat(document.getElementById("up-z").value);
            const bukaanW = parseFloat(document.getElementById("bukaan-w").value); // ini dalam derajat
            const bukaanH = parseFloat(document.getElementById("bukaan-h").value); // ini dalam derajat
            const clipNear = parseFloat(document.getElementById("clip-near").value);
            const clipFar = parseFloat(document.getElementById("clip-far").value);

            let vertices = LEGO_man.vertices.map((v) => {
                return {
                    x: v[0] * size + positionX,
                    y: v[1] * size + positionY,
                    z: v[2] * size + positionZ,
                    w: 1,
                };
            });
            let faces = LEGO_man.faces;

            const translationMatrix = generateTanslasiMatrix(
                cameraX,
                cameraY,
                cameraZ
            );
            const scalingMatrix = generateScalingMatrix(cameraX, cameraY, cameraZ);
            const bukaanMatrix = generateBukaanMatrix(bukaanW, bukaanH);

            const perspectiveMatrix = generatePerspectiveMatrix(clipNear, clipFar);
            const farScalingMatrix = generateFarScalingMatrix(clipFar);

            const transformedVertices = vertices.map((v) => {
                let transformedVertex = multiplyMatrixAndPoint(translationMatrix, v);
                transformedVertex = multiplyMatrixAndPoint(
                    scalingMatrix,
                    transformedVertex
                );
                transformedVertex = multiplyMatrixAndPoint(
                    lookAt(
                        cameraX,
                        cameraY,
                        cameraZ,
                        lookAtX,
                        lookAtY,
                        lookAtZ,
                        upX,
                        upY,
                        upZ
                    ),
                    transformedVertex
                );
                transformedVertex = {
                    x: transformedVertex.x + 200,
                    y: canvas.height - transformedVertex.y - 440,
                    z: transformedVertex.z,
                };
                transformedVertex = multiplyMatrixAndPoint(bukaanMatrix, transformedVertex);
                transformedVertex = multiplyMatrixAndPoint(farScalingMatrix, transformedVertex);
                transformedVertex = multiplyMatrixAndPoint(perspectiveMatrix, transformedVertex);
                //document.write(JSON.stringify(transformedVertex), "<br>");
                return transformedVertex;
            });
            // Apply the projection matrix to each vertex

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            // Draw faces
            faces.forEach((face) => {
                ctx.beginPath();
                face.forEach((vertexIndex, index) => {
                    let indexParts = vertexIndex.split("/");
                    let vertexPositionIndex = parseInt(indexParts[0]);
                    let vert = transformedVertices[vertexPositionIndex - 1];
                    if (index === 0) {
                        ctx.moveTo(vert.x, vert.y);
                    } else {
                        ctx.lineTo(vert.x, vert.y);
                    }
                });
                ctx.closePath();
                ctx.stroke();
            });
        }

        drawCanvas(ctx);
        //document.write(canvas.width, ",", canvas.height);

        /**
        vertices = vertices.map((v) => {
        const translationMatrix = generateTanslasiMatrix(
        cameraX,
        cameraY,
        cameraZ
        );
        return multiplyMatrixAndPoint(translationMatrix, v);
        });
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        vertices.forEach((vert) => {
        ctx.fillRect(vert.x, vert.y, 1, 1);
        });
        console.log(vertices)
        */
    </script>
</body>

</html>