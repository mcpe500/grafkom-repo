monye
<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8" />
    <title>Draw Cube No Shading</title>
    <style>
        body {
            margin: 0;
            background-color: #f0f0f0;
        }

        #canvas {
            border: 1px solid black;
        }
    </style>
</head>

<body>
    <canvas id="canvas" width="1280" height="720"></canvas>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.8.1/gl-matrix-min.js"></script>
    <script>
        var canvas = document.getElementById('canvas');
        var gl = canvas.getContext('webgl2');

        var textureImages = [
            './image/texture/cobblestone.jpg',
            './image/texture/diamond.jpg',
            './image/texture/dirt.jpg',
            './image/texture/emerald.jpg',
            './image/texture/iron.jpg',
            './image/texture/wood.jpg'
        ];

        var textures = [];
        for (var i = 0; i < textureImages.length; i++) {
            var texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture);
            // Set the parameters so we can render any size image.
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            // Upload the image into the texture.
            var image = new Image();
            image.src = textureImages[i];
            image.onload = function () {
                gl.bindTexture(gl.TEXTURE_2D, texture);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
            };
            textures.push(texture);
        }

        gl.viewport(0, 0, canvas.width, canvas.height);
        gl.clearColor(0.2, 0.2, 0.2, 1.0);


        var program = gl.createProgram();
        // Modify the vertex shader
        gl.attachShader(program, createShader(gl, gl.VERTEX_SHADER, `#version 300 es
    precision mediump float;
    in vec3 aPosition;
    in vec2 aTexCoord;
    uniform mat4 uModelViewMatrix;
    uniform mat4 uProjectionMatrix;
    out vec2 vTexCoord;
    void main() {
        gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(aPosition, 1.0);
        vTexCoord = aTexCoord;
    }
`));
        // Modify the fragment shader
        gl.attachShader(program, createShader(gl, gl.FRAGMENT_SHADER, `#version 300 es
    precision mediump float;
    in vec2 vTexCoord;
    uniform sampler2D uTexture;
    out vec4 fragColor;
    void main() {
        fragColor = texture(uTexture, vTexCoord);
    }
`));
        gl.linkProgram(program);
        gl.useProgram(program);

        var vbo = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
        var verticesAndColors = new Float32Array([
            // Front face (red)
            -1, -1, -1, 1, 0, 0, 1,
            1, -1, -1, 1, 0, 0, 1,
            1, 1, -1, 1, 0, 0, 1,
            -1, 1, -1, 1, 0, 0, 1,

            // Back face (green)
            -1, -1, 1, 0, 1, 0, 1,
            1, -1, 1, 0, 1, 0, 1,
            1, 1, 1, 0, 1, 0, 1,
            -1, 1, 1, 0, 1, 0, 1,

            // Top face (blue)
            -1, 1, -1, 0, 0, 1, 1,
            1, 1, -1, 0, 0, 1, 1,
            1, 1, 1, 0, 0, 1, 1,
            -1, 1, 1, 0, 0, 1, 1,

            // Bottom face (yellow)
            -1, -1, -1, 1, 1, 0, 1,
            1, -1, -1, 1, 1, 0, 1,
            1, -1, 1, 1, 1, 0, 1,
            -1, -1, 1, 1, 1, 0, 1,

            // Right face (cyan)
            1, -1, -1, 0, 1, 1, 1,
            1, 1, -1, 0, 1, 1, 1,
            1, 1, 1, 0, 1, 1, 1,
            1, -1, 1, 0, 1, 1, 1,

            // Left face (magenta)
            -1, -1, -1, 1, 0, 1, 1,
            -1, 1, -1, 1, 0, 1, 1,
            -1, 1, 1, 1, 0, 1, 1,
            -1, -1, 1, 1, 0, 1, 1,
        ]);

        gl.bufferData(gl.ARRAY_BUFFER, verticesAndColors, gl.STATIC_DRAW);

        // Setup attribute pointers
        var texCoordAttributeLocation = gl.getAttribLocation(program, "aTexCoord");
        gl.enableVertexAttribArray(texCoordAttributeLocation);
        gl.vertexAttribPointer(texCoordAttributeLocation, 2, gl.FLOAT, false, 5 * 4, 3 * 4);

        // Bind the texture to texture unit 0
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, textures[0]); // Change this for each face

        // Tell the shader we bound the texture to texture unit 0
        var uTexture = gl.getUniformLocation(program, "uTexture");
        gl.uniform1i(uTexture, 0);

        var ibo = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo);

        var indices = new Uint16Array([
            // Front face
            0, 1, 2, 2, 3, 0,

            // Back face
            4, 5, 6, 6, 7, 4,

            // Top face
            8, 9, 10, 10, 11, 8,

            // Bottom face
            12, 13, 14, 14, 15, 12,

            // Right face
            16, 17, 18, 18, 19, 16,

            // Left face
            20, 21, 22, 22, 23, 20
        ]);

        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);

        var modelViewMatrix = mat4.create();
        var projectionMatrix = mat4.create();
        // New perspective camera setup
        var fov = 45; // Field of view in degrees
        var aspect = 16 / 9;
        var near = 0.1;
        var far = 100;
        mat4.perspective(projectionMatrix, fov, aspect, near, far)

        // mat4.ortho(projectionMatrix, -5, 5, -5, 5, -10, 10);
        mat4.lookAt(modelViewMatrix, [-3, 3, 3], [0, 0, 0], [0, 1, 0]);

        var uModelViewMatrix = gl.getUniformLocation(program, 'uModelViewMatrix');
        var uProjectionMatrix = gl.getUniformLocation(program, 'uProjectionMatrix');
        gl.uniformMatrix4fv(uModelViewMatrix, false, modelViewMatrix);
        gl.uniformMatrix4fv(uProjectionMatrix, false, projectionMatrix);

        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        gl.enable(gl.DEPTH_TEST);

        // Bind buffer for vertex attributes
        gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
        gl.bufferData(gl.ARRAY_BUFFER, verticesAndColors, gl.STATIC_DRAW);

        // Bind indices
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);

        // Setup attribute pointers
        var positionAttributeLocation = gl.getAttribLocation(program, "aPosition");
        // var colorAttributeLocation = gl.getAttribLocation(program, "aColor");

        gl.enableVertexAttribArray(positionAttributeLocation);
        gl.vertexAttribPointer(positionAttributeLocation, 3, gl.FLOAT, false, 7 * 4, 0);

        // gl.enableVertexAttribArray(colorAttributeLocation);
        // gl.vertexAttribPointer(colorAttributeLocation, 4, gl.FLOAT, false, 7 * 4, 3 * 4);

        // Draw the cube
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);
        function createShader(gl, type, source) {
            var shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Error compiling shader:', gl.getShaderInfoLog(shader));
                return null;
            }
            return shader;
        }
    </script>
</body>

</html>

<!-- // fetch('./kera.obj')
//     .then(response => response.text())
//     .then(objData => {

            // offset = 0;
            // let count = 3;
            // gl.drawArrays(primitiveType, offset, count);
//     }); -->