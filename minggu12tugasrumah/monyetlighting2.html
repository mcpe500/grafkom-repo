<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
  <title>Monyet Lighting</title>
  <style>
    body {
      margin: 0;
      background-color: #f0f0f0;
    }

    #canvas {
      border: 1px solid black;
    }
  </style>
</head>

<body>
  <canvas id="canvas" width="1280" height="720"></canvas>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.8.1/gl-matrix-min.js"></script>
  <script>
    const createShader = (gl, type, source) => {
      // Create a shader object
      const shader = gl.createShader(type);

      // Set the shader source code
      gl.shaderSource(shader, source);

      // Compile the shader
      gl.compileShader(shader);

      // Check for compilation errors
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error(`Error compiling shader: ${gl.getShaderInfoLog(shader)}`);
        gl.deleteShader(shader);
        return null;
      }

      return shader;
    }

    const createProgram = (gl, vertexShader, fragmentShader) => {
      // Create a program object
      const program = gl.createProgram();

      // Attach shaders to the program
      gl.attachShader(program, vertexShader);
      gl.attachShader(program, fragmentShader);

      // Link the program
      gl.linkProgram(program);

      // Check for linking errors
      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        console.error(`Error linking program: ${gl.getProgramInfoLog(program)}`);
        gl.deleteProgram(program);
        return null;
      }

      return program;
    }

    const mainFunction = async (response) => {
      var canvas = document.getElementById('canvas');
      var gl = canvas.getContext('webgl2');

      const objText = await response.text();
      const lines = objText.split('\n');

      const vertices = [];
      const faces = [];

      for (const line of lines) {
        const tokens = line.trim().split(/\s+/);
        if (!tokens.length) continue;

        if (tokens[0] === 'v') {
          // Vertex coordinates (x, y, z)
          const [x, y, z] = tokens.slice(1).map(parseFloat);
          vertices.push({ x, y, z });
        } else if (tokens[0] === 'f') {
          // Face indices (assuming triangular faces)
          const [v1, v2, v3] = tokens.slice(1).map((token) => parseInt(token.split('/')[0], 10));
          faces.push({ v1, v2, v3 });
        }
      }
      const model = {
        vertices: vertices, // {x,y,z}
        faces: faces, // {v1,v2,v3}
      }

      // Create shaders (vertex shader and fragment shader)
      const vertexShaderSource = `#version 300 es
            // Input attributes
            in vec3 aVertexPosition;
            in vec3 aVertexNormal;

            // Uniforms
            uniform mat4 uModelViewMatrix;
            uniform mat4 uProjectionMatrix;
            uniform mat4 uNormalMatrix;

            // Output variables
            out vec3 vNormal;
            out vec3 vFragPos;

            void main() {
                // Transform vertex position
                gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(aVertexPosition, 1.0);

                // Pass normal to fragment shader
                vNormal = mat3(uNormalMatrix) * aVertexNormal;
                
                // Pass fragment position to fragment shader
                vFragPos = vec3(uModelViewMatrix * vec4(aVertexPosition, 1.0));
            }
        `;

      const fragmentShaderSource = `#version 300 es
            precision highp float;

            // Input variables from vertex shader
            in vec3 vNormal;
            in vec3 vFragPos;

            // Output color
            out vec4 fragColor;

            // Uniforms
            uniform vec3 uLightDirection;
            uniform vec3 uLightColor;
            uniform vec3 uObjectColor;
            uniform float uDiffuseCoefficient;

            void main() {
                // Normalize normal vector
                vec3 normal = normalize(vNormal);
                
                // Calculate light direction (assuming directional light)
                vec3 lightDir = normalize(uLightDirection);
                
                // Calculate diffuse factor using Lambert's law
                float diffuseFactor = max(dot(normal, lightDir), 0.0);
                
                // Calculate diffuse color
                vec3 diffuseColor = uObjectColor * uLightColor * diffuseFactor * uDiffuseCoefficient;
                
                // Set fragment color
                fragColor = vec4(diffuseColor, 1.0);
            }
        `;

      const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
      const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);

      // Create a shader program
      const program = createProgram(gl, vertexShader, fragmentShader);

      // Set up buffers, attributes, and uniforms
      function setupBuffersAndAttributes(gl, program, model) {
        // Create vertex buffer
        const vertexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(model.vertices.map(mv => Object.values(mv)).flat()), gl.STATIC_DRAW);
        // console.log(new Float32Array(model.vertices.map(mv => Object.values(mv)).flat()))
        // console.log(model.vertices.map(mv => Object.values(mv)).flat())
        // console.log(model.vertices.flat())
        // Create index buffer
        const indexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
        const indices = model.faces.map(mf => Object.values(mf)).flat();
        // console.log(new Uint16Array(indices.map(i => Object.values(i)).flat()))
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);

        // Get attribute locations
        const vertexPositionLocation = gl.getAttribLocation(program, 'aVertexPosition');
        const vertexNormalLocation = gl.getAttribLocation(program, 'aVertexNormal');

        // Enable the attributes
        gl.enableVertexAttribArray(vertexPositionLocation);
        gl.enableVertexAttribArray(vertexNormalLocation);

        // Specify how to pull data from the buffers
        gl.vertexAttribPointer(vertexPositionLocation, 3, gl.FLOAT, false, 0, 0);
        gl.vertexAttribPointer(vertexNormalLocation, 3, gl.FLOAT, false, 0, 0);

        // Set uniforms (e.g., light direction, material properties)
        const lightDirection = vec3.fromValues(0.0, 0.0, -1.0); // Example light direction
        const lightColor = vec3.fromValues(1.0, 1.0, 1.0); // White light
        const objectColor = vec3.fromValues(1.0, 0.0, 0.0); // Red object color
        const diffuseCoefficient = 0.8; // Diffuse coefficient

        const uLightDirectionLocation = gl.getUniformLocation(program, 'uLightDirection');
        const uLightColorLocation = gl.getUniformLocation(program, 'uLightColor');
        const uObjectColorLocation = gl.getUniformLocation(program, 'uObjectColor');
        const uDiffuseCoefficientLocation = gl.getUniformLocation(program, 'uDiffuseCoefficient');

        gl.uniform3fv(uLightDirectionLocation, lightDirection);
        gl.uniform3fv(uLightColorLocation, lightColor);
        gl.uniform3fv(uObjectColorLocation, objectColor);
        gl.uniform1f(uDiffuseCoefficientLocation, diffuseCoefficient);
      }

      // Render loop
      function render() {
        // Clear canvas
        gl.clearColor(0.0, 0.0, 0.0, 1.0);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        // Bind shader program
        gl.useProgram(program);

        // Set up buffers and attributes
        setupBuffersAndAttributes(gl, program, model);

        // Draw elements
        gl.drawElements(gl.TRIANGLES, model.faces.length * 3, gl.UNSIGNED_SHORT, 0);

        // requestAnimationFrame(render);
      }

      // Start rendering
      requestAnimationFrame(render);
    }

    fetch("./kera.obj").then(mainFunction);
  </script>
</body>

</html>