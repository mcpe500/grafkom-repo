<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
  <title>Monyet Lighting</title>
  <style>
    body {
      margin: 0;
      background-color: #f0f0f0;
    }

    #canvas {
      border: 1px solid black;
    }
  </style>
</head>

<body>
  <canvas id="canvas" width="1280" height="720"></canvas>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.8.1/gl-matrix-min.js"></script>
  <script>
    const createShader = (gl, type, source) => {
      // Create a shader object
      const shader = gl.createShader(type);

      // Set the shader source code
      gl.shaderSource(shader, source);

      // Compile the shader
      gl.compileShader(shader);

      // Check for compilation errors
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error(`Error compiling shader: ${gl.getShaderInfoLog(shader)}`);
        gl.deleteShader(shader);
        return null;
      }

      return shader;
    }

    const createProgram = (gl, vertexShader, fragmentShader) => {
      // Create a program object
      const program = gl.createProgram();

      // Attach shaders to the program
      gl.attachShader(program, vertexShader);
      gl.attachShader(program, fragmentShader);

      // Link the program
      gl.linkProgram(program);

      // Check for linking errors
      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        console.error(`Error linking program: ${gl.getProgramInfoLog(program)}`);
        gl.deleteProgram(program);
        return null;
      }

      return program;
    }

    const mainFunction = async (response) => {
      var canvas = document.getElementById('canvas');
      var gl = canvas.getContext('webgl2');

      const objText = await response.text();
      const lines = objText.split('\n');

      const vertices = [];
      const faces = [];

      for (const line of lines) {
        const tokens = line.trim().split(/\s+/);
        if (!tokens.length) continue;

        if (tokens[0] === 'v') {
          // Vertex coordinates (x, y, z)
          const [x, y, z] = tokens.slice(1).map(parseFloat);
          vertices.push({ x, y, z });
        } else if (tokens[0] === 'f') {
          // Face indices (assuming triangular faces)
          const [v1, v2, v3] = tokens.slice(1).map((token) => parseInt(token.split('/')[0], 10));
          faces.push({ v1, v2, v3 });
        }
      }
      const model = {
        vertices: vertices, // {x,y,z}
        faces: faces, // {v1,v2,v3}
      }
      const vs = `#version 300 es
attribute vec4 a_position;
attribute vec3 a_normal;
 
uniform mat4 u_projection;
uniform mat4 u_view;
uniform mat4 u_world;
 
varying vec3 v_normal;
 
void main() {
  gl_Position = u_projection * u_view * u_world * a_position;
  v_normal = mat3(u_world) * a_normal;
}
`;

      const fs = `#version 300 es
precision mediump float;
 
varying vec3 v_normal;
 
uniform vec4 u_diffuse;
uniform vec3 u_lightDirection;
 
void main () {
  vec3 normal = normalize(v_normal);
  float fakeLight = dot(u_lightDirection, normal) * .5 + .5;
  gl_FragColor = vec4(u_diffuse.rgb * fakeLight, u_diffuse.a);
}
`;


      // Because data is just named arrays like this
      //
      // {
      //   position: [...],
      //   texcoord: [...],
      //   normal: [...],
      // }
      //
      // and because those names match the attributes in our vertex
      // shader we can pass it directly into `createBufferInfoFromArrays`
      // from the article "less code more fun".

      // create a buffer for each array by calling
      // gl.createBuffer, gl.bindBuffer, gl.bufferData
      const bufferInfo = webglUtils.createBufferInfoFromArrays(gl, data);

      const cameraTarget = [0, 0, 0];
      const cameraPosition = [0, 0, 4];
      const zNear = 0.1;
      const zFar = 50;

      function degToRad(deg) {
        return deg * Math.PI / 180;
      }

      function render(time) {
        time *= 0.001;  // convert to seconds

        webglUtils.resizeCanvasToDisplaySize(gl.canvas);
        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
        gl.enable(gl.DEPTH_TEST);
        gl.enable(gl.CULL_FACE);

        const fieldOfViewRadians = degToRad(60);
        const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
        const projection = m4.perspective(fieldOfViewRadians, aspect, zNear, zFar);

        const up = [0, 1, 0];
        // Compute the camera's matrix using look at.
        const camera = m4.lookAt(cameraPosition, cameraTarget, up);

        // Make a view matrix from the camera matrix.
        const view = m4.inverse(camera);

        const sharedUniforms = {
          u_lightDirection: m4.normalize([-1, 3, 5]),
          u_view: view,
          u_projection: projection,
        };

        gl.useProgram(meshProgramInfo.program);

        // calls gl.uniform
        webglUtils.setUniforms(meshProgramInfo, sharedUniforms);

        // calls gl.bindBuffer, gl.enableVertexAttribArray, gl.vertexAttribPointer
        webglUtils.setBuffersAndAttributes(gl, meshProgramInfo, bufferInfo);

        // calls gl.uniform
        webglUtils.setUniforms(meshProgramInfo, {
          u_world: m4.yRotation(time),
          u_diffuse: [1, 0.7, 0.5, 1],
        });

        // calls gl.drawArrays or gl.drawElements
        webglUtils.drawBufferInfo(gl, bufferInfo);

        requestAnimationFrame(render);
      }
      requestAnimationFrame(render);
      
    }

    fetch("./kera.obj").then(mainFunction);
  </script>
</body>

</html>