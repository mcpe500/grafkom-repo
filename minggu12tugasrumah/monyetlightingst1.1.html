monye
<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8" />
    <title>Monyet Lighting</title>
    <style>
        body {
            margin: 0;
            background-color: #f0f0f0;
        }

        #canvas {
            border: 1px solid black;
        }
    </style>
</head>

<body>
    <canvas id="canvas" width="1280" height="720"></canvas>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.8.1/gl-matrix-min.js"></script>
    <script>
        function calculateNormal(x, y, z, faces) {
            // Assuming faces is an array of objects with v1, v2, v3 properties
            // representing indices of vertices in the vertices array
            const lastFace = faces[faces.length - 1];

            if (!lastFace) return [0, 0, 0]; // Return a default normal if there are no faces yet

            // Get the vertices for the last face
            const v1 = vertices[lastFace.v1 - 1]; // obj indices start at 1
            const v2 = vertices[lastFace.v2 - 1];
            const v3 = vertices[lastFace.v3 - 1];

            // Calculate two vectors from the three points
            const vector1 = [v2.x - v1.x, v2.y - v1.y, v2.z - v1.z];
            const vector2 = [v3.x - v1.x, v3.y - v1.y, v3.z - v1.z];

            // Calculate the cross product of the two vectors
            const normal = [
                vector1[1] * vector2[2] - vector1[2] * vector2[1],
                vector1[2] * vector2[0] - vector1[0] * vector2[2],
                vector1[0] * vector2[1] - vector1[1] * vector2[0],
            ];

            // Normalize the normal vector (make it have length of 1)
            const length = Math.sqrt(
                normal[0] ** 2 + normal[1] ** 2 + normal[2] ** 2
            );
            console.log([normal[0] / length, normal[1] / length, normal[2] / length]);
            return [normal[0] / length, normal[1] / length, normal[2] / length];
        }

        fetch("./kera.obj").then(async (response) => {
            const objText = await response.text();
            const lines = objText.split("\n");

            const vertices = [];
            const faces = [];

            for (const line of lines) {
                const tokens = line.trim().split(/\s+/);
                if (!tokens.length) continue;

                if (tokens[0] === "v") {
                    // Vertex coordinates (x, y, z)
                    const [x, y, z] = tokens.slice(1).map(parseFloat);
                    vertices.push({ x, y, z });
                    const normal = calculateNormal(x, y, z, faces);
                    vertices[vertices.length - 1].normal = normal;
                } else if (tokens[0] === "f") {
                    // Face indices (assuming triangular faces)
                    const [v1, v2, v3] = tokens
                        .slice(1)
                        .map((token) => parseInt(token.split("/")[0], 10));
                    faces.push({ v1, v2, v3 });
                }
            }
            //this is the model
            const model = {
                vertices: vertices, // {x,y,z}
                faces: faces, // {v1,v2,v3}
            };
            // console.log(vertices.length == faces.length, vertices.length, faces.length)

            const canvas = document.querySelector("#canvas");
            const gl = canvas.getContext("webgl2");

            gl.clearColor(0.0, 0.0, 0.0, 1.0); // Set clear color to black, fully opaque
            gl.clear(gl.COLOR_BUFFER_BIT); // Clear the color buffer with specified clear color

            const vertexShader = gl.createShader(gl.VERTEX_SHADER); // Create vertex shader
            const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER); // Create fragment shader
            // Vertex Shader
            //             let vertexShaderSource = `#version 300 es
            // in vec4 a_position;

            // void main() {
            //     gl_Position = a_position;
            // }`;
            // Vertex Shader
            let vertexShaderSource = `#version 300 es
in vec4 a_position;
in vec3 a_normal;

uniform mat4 u_modelViewMatrix;
uniform mat4 u_projectionMatrix;
uniform mat3 u_normalMatrix;

out vec3 v_normal;

void main() {
    gl_Position = u_projectionMatrix * u_modelViewMatrix * a_position;
    v_normal = u_normalMatrix * a_normal;
}`;

            // Fragment Shader
            //             let fragmentShaderSource = `#version 300 es
            // precision mediump float;

            // out vec4 outColor;

            // void main() {
            //     outColor = vec4(1, 0, 0.5, 1);  // pink color
            // }`;
            // Fragment Shader
            let fragmentShaderSource = `#version 300 es
precision mediump float;

in vec3 v_normal;

uniform vec3 u_lightColor;
uniform vec3 u_lightDirection;
uniform vec4 u_color;

out vec4 outColor;

void main() {
    vec3 normal = normalize(v_normal);
    float light = dot(normal, u_lightDirection);
    outColor = u_color * (0.2 + 0.8 * light);
}`;

            // Create and setup a vertex array object
            const vao = gl.createVertexArray();
            gl.bindVertexArray(vao);

            gl.shaderSource(vertexShader, vertexShaderSource);
            gl.shaderSource(fragmentShader, fragmentShaderSource);

            gl.compileShader(vertexShader);
            gl.compileShader(fragmentShader);

            if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
                console.error(gl.getShaderInfoLog(vertexShader));
            }
            if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
                console.error(gl.getShaderInfoLog(fragmentShader));
            }

            let shaderProgram = gl.createProgram();
            gl.attachShader(shaderProgram, vertexShader);
            gl.attachShader(shaderProgram, fragmentShader);
            gl.linkProgram(shaderProgram);

            gl.useProgram(shaderProgram);
            // Create a buffer for the positions.
            const positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);

            const modelViewMatrix = mat4.create();
            mat4.translate(modelViewMatrix, modelViewMatrix, [-0.0, 0.0, -6]);

            const projectionMatrix = mat4.create();
            mat4.perspective(
                projectionMatrix,
                Math.PI / 4,
                canvas.width / canvas.height,
                1,
                100
            );

            const normalMatrix = mat3.create();
            mat3.normalFromMat4(normalMatrix, modelViewMatrix);

            const colorUniform = gl.getUniformLocation(shaderProgram, "u_color");
            gl.uniform4fv(colorUniform, [1, 1, 1, 1]);

            const lightColorUniform = gl.getUniformLocation(
                shaderProgram,
                "u_lightColor"
            );
            gl.uniform3fv(lightColorUniform, [1, 1, 1]);

            const lightDirectionUniform = gl.getUniformLocation(
                shaderProgram,
                "u_lightDirection"
            );
            const lightDirection = [-0.5, 0.7, 0.5];
            gl.uniform3fv(lightDirectionUniform, lightDirection);

            const modelViewMatrixUniform = gl.getUniformLocation(
                shaderProgram,
                "u_modelViewMatrix"
            );
            gl.uniformMatrix4fv(modelViewMatrixUniform, false, modelViewMatrix);

            const projectionMatrixUniform = gl.getUniformLocation(
                shaderProgram,
                "u_projectionMatrix"
            );
            gl.uniformMatrix4fv(projectionMatrixUniform, false, projectionMatrix);

            const normalMatrixUniform = gl.getUniformLocation(
                shaderProgram,
                "u_normalMatrix"
            );
            gl.uniformMatrix3fv(normalMatrixUniform, false, normalMatrix);

            // Set positions of vertices
            const positions = vertices
                .map(({ x, y, z }) => [x, y, z])
                .flat()
                .map((v) => v * 0.6);

            gl.bufferData(
                gl.ARRAY_BUFFER,
                new Float32Array(positions),
                gl.STATIC_DRAW
            );
            const normals = vertices.map(({ normal }) => normal).flat();
            console.log(normals)
            const normalBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
            gl.bufferData(
                gl.ARRAY_BUFFER,
                new Float32Array(normals),
                gl.STATIC_DRAW
            );

            let normalAttributeLocation = gl.getAttribLocation(
                shaderProgram,
                "a_normal"
            );
            gl.enableVertexAttribArray(normalAttributeLocation);
            gl.vertexAttribPointer(
                normalAttributeLocation,
                3,
                gl.FLOAT,
                false,
                0,
                0
            );

            // Create an element buffer for the face indices
            const elementBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, elementBuffer);

            // Set face indices
            const indices = faces
                .map(({ v1, v2, v3 }) => [v1 - 1, v2 - 1, v3 - 1])
                .flat(); // obj indices start at 1
            gl.bufferData(
                gl.ELEMENT_ARRAY_BUFFER,
                new Uint16Array(indices),
                gl.STATIC_DRAW
            );

            // Turn on the attribute
            let positionAttributeLocation = gl.getAttribLocation(
                shaderProgram,
                "a_position"
            );
            gl.enableVertexAttribArray(positionAttributeLocation);

            // Tell the attribute how to get data out of positionBuffer
            let size = 3; // 3 components per iteration
            let type = gl.FLOAT; // the data is 32bit floats
            let normalize = false; // don't normalize the data
            let stride = 0; // 0 = move forward size * sizeof(type) each iteration to get the next position
            let offset = 0; // start at the beginning of the buffer
            gl.vertexAttribPointer(
                positionAttributeLocation,
                size,
                type,
                normalize,
                stride,
                offset
            );

            // draw
            let primitiveType = gl.TRIANGLES;
            let count = indices.length;
            gl.drawElements(primitiveType, count, gl.UNSIGNED_SHORT, offset);
        });
    </script>
</body>

</html>

<!-- // fetch('./kera.obj')
//     .then(response => response.text())
//     .then(objData => {

            // offset = 0;
            // let count = 3;
            // gl.drawArrays(primitiveType, offset, count);
//     }); -->