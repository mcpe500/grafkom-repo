<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGL OBJ Loader Example</title>
</head>

<body>
    <canvas id="webglCanvas"></canvas>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.4.0/gl-matrix-min.js"></script>
    <script>
        function parseOBJ(objText) {
            const vertices = [];
            const normals = [];
            const textureCoords = [];
            const faces = [];

            const lines = objText.split('\n');

            for (const line of lines) {
                const parts = line.trim().split(/\s+/);

                switch (parts[0]) {
                    case 'v':
                        vertices.push(parts.slice(1).map(Number));
                        break;
                    case 'vn':
                        normals.push(parts.slice(1).map(Number));
                        break;
                    case 'vt':
                        textureCoords.push(parts.slice(1).map(Number));
                        break;
                    case 'f':
                        const faceParts = parts.slice(1);
                        const facesIndices = faceParts.map(str => {
                            const indices = str.split('/').map(index => parseInt(index, 10) - 1);
                            return {
                                vertexIndex: indices[0],
                                textureCoordIndex: indices[1],
                                normalIndex: indices[2],
                            };
                        });

                        // Jika ada 4 indeks, pecah menjadi dua wajah segitiga
                        if (facesIndices.length === 4) {
                            faces.push([facesIndices[0], facesIndices[1], facesIndices[2]]);
                            faces.push([facesIndices[0], facesIndices[2], facesIndices[3]]);
                        } else {
                            faces.push(facesIndices);
                        }
                        break;
                }
            }

            return {
                vertices,
                normals,
                textureCoords,
                faces,
            };
        }

        fetch('./objects/kera.obj')
            .then(response => response.text())
            .then(text => {
                const hasil = parseOBJ(text);




                // WebGL Initialization
                const canvas = document.getElementById('webglCanvas');
                const gl = canvas.getContext('webgl2');

                // Vertex shader source
                const vertexShaderSource = `#version 300 es
    in vec4 a_position;
    in vec3 a_normal;
    uniform mat4 u_modelViewProjectionMatrix;
    uniform mat3 u_normalMatrix;
    out vec3 v_normal;
    void main() {
      gl_Position = u_modelViewProjectionMatrix * a_position;
      v_normal = u_normalMatrix * a_normal;
    }
    `;

                // Fragment shader source
                const fragmentShaderSource = `#version 300 es
	precision mediump float;
	in vec3 v_normal;
	uniform vec3 u_lightDirection;
	uniform vec3 u_viewDirection;
	uniform vec3 u_lightColor;
	uniform vec3 u_ambientColor;
	uniform vec3 u_baseColor;
	out vec4 outColor;

	void main() {
		vec3 normal = normalize(v_normal);
		vec3 lightDirection = normalize(u_lightDirection);
		vec3 viewDirection = normalize(u_viewDirection);

		float diffuseStrength = max(0.0, dot(normal, lightDirection));
		vec3 diffuseColor = u_lightColor * u_baseColor * diffuseStrength;

		vec3 reflectedLightDirection = reflect(-lightDirection, normal);
		float specularStrength = pow(max(0.0, dot(viewDirection, reflectedLightDirection)), 64.0);
		vec3 specularColor = u_lightColor * specularStrength;

		vec3 ambientColor = u_ambientColor;

		vec3 finalColor = ambientColor + diffuseColor + specularColor;
		outColor = vec4(finalColor, 1.0);
	}
	`;

                // Compile a shader
                function compileShader(gl, type, source) {
                    const shader = gl.createShader(type);
                    gl.shaderSource(shader, source);
                    gl.compileShader(shader);

                    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                        console.error('Error compiling shader:', gl.getShaderInfoLog(shader));
                        gl.deleteShader(shader);
                        return null;
                    }

                    return shader;
                }

                // Initialize the shaders
                const vertexShader = compileShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
                const fragmentShader = compileShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);

                // Create the program
                const program = gl.createProgram();
                gl.attachShader(program, vertexShader);
                gl.attachShader(program, fragmentShader);
                gl.linkProgram(program);

                /*
                    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                      console.error('Error linking program:', gl.getProgramInfoLog(program));
                      gl.deleteProgram(program);
                      return;
                    }
                */

                gl.useProgram(program);

                // Get attribute and uniform locations
                const a_position = gl.getAttribLocation(program, 'a_position');
                const a_normal = gl.getAttribLocation(program, 'a_normal');
                const u_modelViewProjectionMatrix = gl.getUniformLocation(program, 'u_modelViewProjectionMatrix');
                const u_normalMatrix = gl.getUniformLocation(program, 'u_normalMatrix');

                const u_lightDirection = gl.getUniformLocation(program, 'u_lightDirection');
                const u_viewDirection = gl.getUniformLocation(program, 'u_viewDirection');
                const u_lightColor = gl.getUniformLocation(program, 'u_lightColor');
                const u_ambientColor = gl.getUniformLocation(program, 'u_ambientColor');
                const u_baseColor = gl.getUniformLocation(program, 'u_baseColor');


                gl.uniform3fv(u_lightDirection, [0, 5, 5]);
                gl.uniform3fv(u_viewDirection, [0, 0, 1]);
                gl.uniform3fv(u_lightColor, [1, 1, 1]);
                gl.uniform3fv(u_ambientColor, [0.05, 0.05, 0.05]);
                gl.uniform3fv(u_baseColor, [1, 1, 1]);


                // Create a single array for the combined attributes
                let uniqueIndex = 0;
                const uniqueIndices = [];
                const indexMap = new Map();

                const combinedAttributes = [];
                for (const face of hasil.faces) {
                    for (const vertex of face) {
                        const position = hasil.vertices[vertex.vertexIndex];
                        const normal = hasil.normals[vertex.normalIndex];

                        const key = vertex.vertexIndex + '/' + vertex.normalIndex;
                        if (!indexMap.has(key)) {
                            indexMap.set(key, uniqueIndex++);
                            uniqueIndices.push(indexMap.get(key));
                            combinedAttributes.push(...position, ...normal);
                        } else {
                            uniqueIndices.push(indexMap.get(key));
                        }
                    }
                }


                // Create the vertex buffer
                const vertexBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(combinedAttributes), gl.STATIC_DRAW);

                // Create the index buffer
                const indexBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(uniqueIndices), gl.STATIC_DRAW);

                // Set up the vertex attributes
                gl.vertexAttribPointer(a_position, 3, gl.FLOAT, false, 6 * Float32Array.BYTES_PER_ELEMENT, 0);
                gl.enableVertexAttribArray(a_position);

                gl.vertexAttribPointer(a_normal, 3, gl.FLOAT, false, 6 * Float32Array.BYTES_PER_ELEMENT, 3 * Float32Array.BYTES_PER_ELEMENT);
                gl.enableVertexAttribArray(a_normal);

                // Resize the canvas
                function resizeCanvas() {
                    canvas.width = window.innerWidth;
                    canvas.height = window.innerHeight;
                    gl.viewport(0, 0, canvas.width, canvas.height);
                }
                resizeCanvas();
                window.addEventListener('resize', resizeCanvas);

                // Set up the model, view, and projection matrices
                const modelMatrix = mat4.create();
                const viewMatrix = mat4.create();
                const projectionMatrix = mat4.create();
                const modelViewProjectionMatrix = mat4.create();
                const normalMatrix = mat3.create();

                // Set up the view matrix (camera)
                mat4.lookAt(viewMatrix, [0, 0, 5], [0, 0, 0], [0, 1, 0]);

                // Set up the projection matrix
                function updateProjectionMatrix() {
                    const aspectRatio = canvas.width / canvas.height;
                    mat4.perspective(projectionMatrix, Math.PI / 4, aspectRatio, 0.1, 100);
                }
                updateProjectionMatrix();
                window.addEventListener('resize', updateProjectionMatrix);

                // Update the model-view-projection matrix and the normal matrix
                function updateMatrices() {
                    mat4.multiply(modelViewProjectionMatrix, projectionMatrix, viewMatrix);
                    mat4.multiply(modelViewProjectionMatrix, modelViewProjectionMatrix, modelMatrix);

                    mat3.normalFromMat4(normalMatrix, modelMatrix);

                    gl.uniformMatrix4fv(u_modelViewProjectionMatrix, false, modelViewProjectionMatrix);
                    gl.uniformMatrix3fv(u_normalMatrix, false, normalMatrix);
                }
                updateMatrices();

                // Animate the object
                function animateObject(currentTime) {
                    const deltaTime = (currentTime - previousTime) / 1000;
                    previousTime = currentTime;

                    // Rotate the object
                    mat4.rotateY(modelMatrix, modelMatrix, deltaTime);
                    updateMatrices();
                }

                // Clear the canvas and draw the object
                function drawObject() {
                    gl.clearColor(0.4, 0.4, 0.4, 1);
                    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

                    gl.enable(gl.DEPTH_TEST);
                    gl.depthFunc(gl.LEQUAL);

                    gl.drawElements(gl.TRIANGLES, uniqueIndices.length, gl.UNSIGNED_SHORT, 0);
                }

                // Render loop
                // Variables for animation
                let previousTime = 0;

                function render(currentTime) {
                    // Animate the object
                    animateObject(currentTime);

                    // Draw the object
                    drawObject();

                    requestAnimationFrame(render);
                }

                // Start the render loop
                requestAnimationFrame(render);
            });
    </script>
</body>

</html>