<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
  <title>Monyet Lighting</title>
  <style>
    body {
      margin: 0;
      background-color: #f0f0f0;
    }

    #canvas {
      border: 1px solid black;
    }
  </style>
</head>

<body>
  <canvas id="canvas" width="1280" height="720"></canvas>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.8.1/gl-matrix-min.js"></script>
  <script>
    "use strict";
    // Compile a shader
    function compileShader(gl, shaderSource, shaderType) {
      const shader = gl.createShader(shaderType);
      gl.shaderSource(shader, shaderSource);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        throw new Error(gl.getShaderInfoLog(shader));
      }
      return shader;
    }

    // Link a program
    function linkProgram(gl, vertexShader, fragmentShader) {
      const program = gl.createProgram();
      gl.attachShader(program, vertexShader);
      gl.attachShader(program, fragmentShader);
      gl.linkProgram(program);
      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        throw new Error(gl.getProgramInfoLog(program));
      }
      return program;
    }

    // This is not a full .obj parser.
    // see http://paulbourke.net/dataformats/obj/

    function parseOBJ(text) {
      // because indices are base 1 let's just fill in the 0th data
      const objPositions = [[0, 0, 0]];
      const objTexcoords = [[0, 0]];
      const objNormals = [[0, 0, 0]];

      // same order as `f` indices
      const objVertexData = [
        objPositions,
        objTexcoords,
        objNormals,
      ];

      // same order as `f` indices
      let webglVertexData = [
        [],   // positions
        [],   // texcoords
        [],   // normals
      ];

      function newGeometry() {
        // If there is an existing geometry and it's
        // not empty then start a new one.
        if (geometry && geometry.data.position.length) {
          geometry = undefined;
        }
        setGeometry();
      }

      function addVertex(vert) {
        const ptn = vert.split('/');
        ptn.forEach((objIndexStr, i) => {
          if (!objIndexStr) {
            return;
          }
          const objIndex = parseInt(objIndexStr);
          const index = objIndex + (objIndex >= 0 ? 0 : objVertexData[i].length);
          webglVertexData[i].push(...objVertexData[i][index]);
        });
      }

      const keywords = {
        v(parts) {
          objPositions.push(parts.map(parseFloat));
        },
        vn(parts) {
          objNormals.push(parts.map(parseFloat));
        },
        vt(parts) {
          // should check for missing v and extra w?
          objTexcoords.push(parts.map(parseFloat));
        },
        f(parts) {
          const numTriangles = parts.length - 2;
          for (let tri = 0; tri < numTriangles; ++tri) {
            addVertex(parts[0]);
            addVertex(parts[tri + 1]);
            addVertex(parts[tri + 2]);
          }
        },
      };

      const keywordRE = /(\w*)(?: )*(.*)/;
      const lines = text.split('\n');
      for (let lineNo = 0; lineNo < lines.length; ++lineNo) {
        const line = lines[lineNo].trim();
        if (line === '' || line.startsWith('#')) {
          continue;
        }
        const m = keywordRE.exec(line);
        if (!m) {
          continue;
        }
        const [, keyword, unparsedArgs] = m;
        const parts = line.split(/\s+/).slice(1);
        const handler = keywords[keyword];
        if (!handler) {
          console.warn('unhandled keyword:', keyword);  // eslint-disable-line no-console
          continue;
        }
        handler(parts, unparsedArgs);
      }

      return {
        position: webglVertexData[0],
        texcoord: webglVertexData[1],
        normal: webglVertexData[2],
      };
    }

    async function main() {
      // Get A WebGL context
      /** @type {HTMLCanvasElement} */
      const canvas = document.querySelector("#canvas");
      const gl = canvas.getContext("webgl2");
      if (!gl) {
        return;
      }

      // Tell the twgl to match position with a_position etc..
      // twgl.setAttributePrefix("a_");

      const vs = `#version 300 es
  in vec4 a_position;
  in vec3 a_normal;

  uniform mat4 u_projection;
  uniform mat4 u_view;
  uniform mat4 u_world;

  out vec3 v_normal;

  void main() {
    gl_Position = u_projection * u_view * u_world * a_position;
    v_normal = mat3(u_world) * a_normal;
  }
  `;

      const fs = `#version 300 es
  precision highp float;

  in vec3 v_normal;

  uniform vec4 u_diffuse;
  uniform vec3 u_lightDirection;

  out vec4 outColor;

  void main () {
    vec3 normal = normalize(v_normal);
    float fakeLight = dot(u_lightDirection, normal) * .5 + .5;
    outColor = vec4(u_diffuse.rgb * fakeLight, u_diffuse.a);
  }
  `;


      // compiles and links the shaders, looks up attribute and uniform locations
      // const meshProgramInfo = twgl.createProgramInfo(gl, [vs, fs]);
      // Compile and link the shaders
      const vertexShader = compileShader(gl, vs, gl.VERTEX_SHADER);
      const fragmentShader = compileShader(gl, fs, gl.FRAGMENT_SHADER);
      const program = linkProgram(gl, vertexShader, fragmentShader);

      // Look up attribute and uniform locations
      const meshProgramInfo = {
        program: program,
        attribLocations: {
          position: gl.getAttribLocation(program, 'a_position'),
          normal: gl.getAttribLocation(program, 'a_normal'),
        },
        uniformLocations: {
          projection: gl.getUniformLocation(program, 'u_projection'),
          view: gl.getUniformLocation(program, 'u_view'),
          world: gl.getUniformLocation(program, 'u_world'),
          diffuse: gl.getUniformLocation(program, 'u_diffuse'),
          lightDirection: gl.getUniformLocation(program, 'u_lightDirection'),
        },
      };
      /**
       * generate the alternative code for twgl using this
       * https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.8.1/gl-matrix-min.js
       * */

      const response = await fetch('https://webgl2fundamentals.org/webgl/resources/models/cube/cube.obj');
      const text = await response.text();
      const data = parseOBJ(text);

      // Because data is just named arrays like this
      //
      // {
      //   position: [...],
      //   texcoord: [...],
      //   normal: [...],
      // }
      //
      // and because those names match the attributes in our vertex
      // shader we can pass it directly into `createBufferInfoFromArrays`
      // from the article "less code more fun".


      /**
       * generate the alternative code for twgl using this
       * https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.8.1/gl-matrix-min.js
       * */
      // create a buffer for each array by calling
      // gl.createBuffer, gl.bindBuffer, gl.bufferData
      // const bufferInfo = twgl.createBufferInfoFromArrays(gl, data);
      const buffers = Object.keys(data).reduce((acc, key) => {
        const buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data[key]), gl.STATIC_DRAW);
        acc[key] = buffer;
        return acc;
      }, {});

      const bufferInfo = {
        numElements: data.position.length / 3,  // assuming 3 components per vertex
        elementType: gl.FLOAT,  // assuming data is of type float
        buffers: buffers,
      };


      /**
       * generate the alternative code for twgl using this
       * https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.8.1/gl-matrix-min.js
       * */
      // fills out a vertex array by calling gl.createVertexArray, gl.bindVertexArray
      // then gl.bindBuffer, gl.enableVertexAttribArray, and gl.vertexAttribPointer for each attribute
      const vao = gl.createVertexArray();
      gl.bindVertexArray(vao);
      console.log(bufferInfo.buffsers)
      Object.keys(bufferInfo.attribs).forEach(name => {
        const buffer = bufferInfo.attribs[name].buffer;
        const numComponents = bufferInfo.attribs[name].numComponents || 3;
        const type = bufferInfo.attribs[name].type || gl.FLOAT;
        const normalize = bufferInfo.attribs[name].normalize || false;
        const stride = bufferInfo.attribs[name].stride || 0;
        const offset = bufferInfo.attribs[name].offset || 0;

        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.vertexAttribPointer(
          meshProgramInfo.attribLocations[name],
          numComponents,
          type,
          normalize,
          stride,
          offset
        );
        gl.enableVertexAttribArray(
          meshProgramInfo.attribLocations[name]
        );
      });

      gl.bindVertexArray(null);

      const cameraTarget = [0, 0, 0];
      const cameraPosition = [0, 0, 4];
      const zNear = 0.1;
      const zFar = 50;

      function degToRad(deg) {
        return deg * Math.PI / 180;
      }

      function render(time) {
        time *= 0.001;  // convert to seconds

        /**
         * generate the alternative code for twgl using this
         * https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.8.1/gl-matrix-min.js
         * */
        // twgl.resizeCanvasToDisplaySize(gl.canvas);
        gl.canvas.width = window.innerWidth;
        gl.canvas.height = window.innerHeight;

        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
        gl.enable(gl.DEPTH_TEST);
        gl.enable(gl.CULL_FACE);

        const fieldOfViewRadians = degToRad(60);
        const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
        const projection = m4.perspective(fieldOfViewRadians, aspect, zNear, zFar);

        const up = [0, 1, 0];
        // Compute the camera's matrix using look at.
        const camera = m4.lookAt(cameraPosition, cameraTarget, up);

        // Make a view matrix from the camera matrix.
        const view = m4.inverse(camera);

        const sharedUniforms = {
          u_lightDirection: m4.normalize([-1, 3, 5]),
          u_view: view,
          u_projection: projection,
        };

        gl.useProgram(meshProgramInfo.program);

        /**
         * generate the alternative code for twgl using this
         * https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.8.1/gl-matrix-min.js
         * */
        // calls gl.uniform
        // twgl.setUniforms(meshProgramInfo, sharedUniforms);
        // Assuming sharedUniforms is an object like this:
        // const sharedUniforms = {
        //   u_lightWorldPosition: [1, 8, -10],
        //   u_lightColor: [1, 0.8, 0.8, 1],
        //   u_ambient: [0, 0, 0, 1],
        //   u_specular: [1, 1, 1, 1],
        //   u_shininess: 50,
        //   u_specularFactor: 0.2,
        //   u_diffuse: twgl.m4.identity(),
        //   u_viewInverse: twgl.m4.identity(),
        //   u_world: twgl.m4.identity(),
        // };

        Object.keys(sharedUniforms).forEach((uniformName) => {
          const uniformLocation = gl.getUniformLocation(meshProgramInfo.program, uniformName);
          const uniformValue = sharedUniforms[uniformName];

          if (Array.isArray(uniformValue) && uniformValue.length === 4) {
            gl.uniform4fv(uniformLocation, uniformValue);
          } else if (Array.isArray(uniformValue) && uniformValue.length === 3) {
            gl.uniform3fv(uniformLocation, uniformValue);
          } else if (Array.isArray(uniformValue) && uniformValue.length === 2) {
            gl.uniform2fv(uniformLocation, uniformValue);
          } else if (Array.isArray(uniformValue) && uniformValue.length === 1) {
            gl.uniform1fv(uniformLocation, uniformValue);
          } else if (typeof uniformValue === 'number') {
            gl.uniform1f(uniformLocation, uniformValue);
          } else {
            throw new Error(`Unsupported uniform type for uniform ${uniformName}`);
          }
        });

        // set the attributes for this part.
        gl.bindVertexArray(vao);

        /**
         * generate the alternative code for twgl using this
         * https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.8.1/gl-matrix-min.js
         * */
        // calls gl.uniform
        // twgl.setUniforms(meshProgramInfo, {
        //   u_world: m4.yRotation(time),
        //   u_diffuse: [1, 0.7, 0.5, 1],
        // });
        const uniforms = {
          u_world: m4.yRotation(time),
          u_diffuse: [1, 0.7, 0.5, 1],
        };

        Object.keys(uniforms).forEach((uniformName) => {
          const uniformLocation = gl.getUniformLocation(meshProgramInfo.program, uniformName);
          const uniformValue = uniforms[uniformName];
          if (Array.isArray(uniformValue) && uniformValue.length === 4) {
            gl.uniform4fv(uniformLocation, uniformValue);
          } else if (typeof uniformValue === 'number') {
            gl.uniform1f(uniformLocation, uniformValue);
          } else {
            throw new Error(`Unsupported uniform type for uniform ${uniformName}`);
          }
        });

        /**
         * generate the alternative code for twgl using this
         * https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.8.1/gl-matrix-min.js
         * */
        // calls gl.drawArrays or gl.drawElements
        // twgl.drawBufferInfo(gl, bufferInfo);
        // Use the program
        gl.useProgram(meshProgramInfo.program);

        // Bind the Vertex Array Object
        gl.bindVertexArray(vao);

        // Set the uniforms
        let projectionMatrix = glMatrix.mat4.create();
        let viewMatrix = glMatrix.mat4.create();
        let worldMatrix = glMatrix.mat4.create();

        glMatrix.mat4.perspective(projectionMatrix, degToRad(60), gl.canvas.width / gl.canvas.height, zNear, zFar);
        glMatrix.mat4.lookAt(viewMatrix, cameraPosition, cameraTarget, [0, 1, 0]);
        glMatrix.mat4.rotateY(worldMatrix, worldMatrix, time);

        gl.uniformMatrix4fv(meshProgramInfo.uniformLocations.projection, false, projectionMatrix);
        gl.uniformMatrix4fv(meshProgramInfo.uniformLocations.view, false, viewMatrix);
        gl.uniformMatrix4fv(meshProgramInfo.uniformLocations.world, false, worldMatrix);

        // Draw the object
        gl.drawArrays(gl.TRIANGLES, 0, bufferInfo.numElements);

        requestAnimationFrame(render);
      }
      requestAnimationFrame(render);
    }

    main();
  </script>
</body>

</html>