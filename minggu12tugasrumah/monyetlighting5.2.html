<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" />
  <title>Monyet Lighting</title>
  <style>
    body {
      margin: 0;
      background-color: #f0f0f0;
    }

    #canvas {
      border: 1px solid black;
    }
  </style>
</head>

<body>
  <canvas id="canvas" width="1280" height="720"></canvas>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.8.1/gl-matrix-min.js"></script>
  <script>
    const canvas = document.querySelector("#canvas");
    const gl = canvas.getContext("webgl2");
    const vsSource = `#version 300 es
in vec4 aVertexPosition;

uniform mat4 uModelViewMatrix;
uniform mat4 uProjectionMatrix;

void main() {
  gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;
}
`;

// fragColor = vec4(1.0, 0.5, 0.2, 1.0);
    const fsSource = `#version 300 es
precision highp float;
out vec4 fragColor;

void main() {
  fragColor = vec4(1.0, 1.0, 1.0, 1.0);
}
`;

    const mainFunction = async (response) => {

      const objText = await response.text();
      const lines = objText.split('\n');

      const vertices = [];
      const faces = [];

      for (const line of lines) {
        const tokens = line.trim().split(/\s+/);
        if (!tokens.length) continue;

        if (tokens[0] === 'v') {
          // Vertex coordinates (x, y, z)
          const [x, y, z] = tokens.slice(1).map(parseFloat);
          vertices.push({ x, y, z });
        } else if (tokens[0] === 'f') {
          // Face indices (assuming triangular faces)
          const [v1, v2, v3] = tokens.slice(1).map((token) => parseInt(token.split('/')[0], 10));
          faces.push({ v1, v2, v3 });
        }
      }
      //this is the model
      const model = {
        vertices: vertices, // {x,y,z}
        faces: faces, // {v1,v2,v3}
      }

      const vertexShader = gl.createShader(gl.VERTEX_SHADER);
      gl.shaderSource(vertexShader, vsSource);
      gl.compileShader(vertexShader);

      const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
      gl.shaderSource(fragmentShader, fsSource);
      gl.compileShader(fragmentShader);

      const shaderProgram = gl.createProgram();
      gl.attachShader(shaderProgram, vertexShader);
      gl.attachShader(shaderProgram, fragmentShader);
      gl.linkProgram(shaderProgram);

      gl.useProgram(shaderProgram);



      const vertexBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices.flatMap(({ x, y, z }) => [x, y, z])), gl.STATIC_DRAW);

      const indexBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(faces.flatMap(({ v1, v2, v3 }) => [v1 - 1, v2 - 1, v3 - 1])), gl.STATIC_DRAW);
      // console.log(new Uint16Array(faces.flatMap(({ v1, v2, v3 }) => [v1 - 1, v2 - 1, v3 - 1])))

      const aVertexPosition = gl.getAttribLocation(shaderProgram, 'aVertexPosition');
      gl.vertexAttribPointer(aVertexPosition, 3, gl.FLOAT, false, 0, 0);
      gl.enableVertexAttribArray(aVertexPosition);

      gl.clearColor(0.0, 0.0, 0.0, 1.0);
      gl.clear(gl.COLOR_BUFFER_BIT);

      gl.viewport(0, 0, canvas.width, canvas.height);

      const modelViewMatrix = mat4.create();
      const projectionMatrix = mat4.create();
      mat4.perspective(projectionMatrix, Math.PI / 4, canvas.width / canvas.height, 1, 100);

      const uModelViewMatrix = gl.getUniformLocation(shaderProgram, 'uModelViewMatrix');
      gl.uniformMatrix4fv(uModelViewMatrix, false, modelViewMatrix);

      const uProjectionMatrix = gl.getUniformLocation(shaderProgram, 'uProjectionMatrix');
      gl.uniformMatrix4fv(uProjectionMatrix, false, projectionMatrix);

      // gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
      gl.drawElements(gl.TRIANGLES, faces.length * 3, gl.UNSIGNED_SHORT, 0);

    }

    fetch("./kera.obj").then(mainFunction)
  </script>
</body>

</html>
<!-- // console.log(model)
// const maxx = {
//   x: Math.max(...model.vertices.map((v) => v.x)),
//   y: Math.max(...model.vertices.map((v) => v.y)),
//   z: Math.max(...model.vertices.map((v) => v.z)),
// }
// const minn = {
//   x: Math.min(...model.vertices.map((v) => v.x)),
//   y: Math.min(...model.vertices.map((v) => v.y)),
//   z: Math.min(...model.vertices.map((v) => v.z)),
// }
// console.log({maxx,minn}) -->